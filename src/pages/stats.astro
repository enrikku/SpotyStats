---
import MainLayout from "../layouts/MainLayout.astro";
import MiniCardStats from "../components/MiniCardStats.astro";
import TopArtistItem from "../components/TopArtistItem.astro";
import Loading from "../components/Loading.astro";
---

<MainLayout content={{ title: "History Stats" }}>
  <Loading />
  <section class="p-6 max-w-7xl mx-auto text-white">
    <div id="divDataNoLoaded" class="flex flex-col items-center mt-10">
      <h1 class="text-4xl font-extrabold text-center mb-4 text-white">Upload Your Spotify History</h1>

      <p class="text-gray-400 text-center max-w-md mb-6">
        Upload your <b>Streaming History JSON</b> files to generate your personalized listening stats.
      </p>

      <div
        class="bg-[#0f172a] p-8 rounded-2xl shadow-xl border border-gray-700 max-w-md w-full flex flex-col items-center gap-5"
      >
        <!-- Icono moderno -->
        <div class="bg-[#1e293b] p-4 rounded-full shadow-md border border-gray-600">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="w-10 h-10 text-green-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1M16 12l-4 4m0 0l-4-4m4 4V4"></path>
          </svg>
        </div>

        <p class="text-gray-300 text-center">
          Drag and drop your <b>.json</b> files or choose them manually.
        </p>

        <!-- Bot√≥n -->
        <label
          for="jsonInput"
          class="cursor-pointer px-6 py-3 bg-green-600 hover:bg-green-700 transition-colors text-white font-medium rounded-lg shadow-md w-fit"
        >
          üìÅ Select JSON Files
        </label>

        <!-- Input oculto -->
        <input type="file" id="jsonInput" class="hidden" accept="application/json" multiple />
      </div>
    </div>

    <div id="divDataLoaded" class="hidden">
      <div class="flex flex-col items-center">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-6 sm:mb-8 text-primary bg-clip-text">
          Basic Info
        </h1>
        <div class="grid grid-cols-2 gap-4 sm:gap-6">
          <MiniCardStats title="Total Songs Played" idP="totalSongsPlayed" />
          <MiniCardStats title="Different Songs" idP="diferentSongs" />
          <MiniCardStats title="Total Minutes" idP="totalMinutes" />
          <MiniCardStats title="Different Artists" idP="diferentArtists" />
          <MiniCardStats title="Total Hours" idP="totalHours" />
          <MiniCardStats title="Different Albums" idP="diferentAlbums" />
          <div class="col-span-2 grid place-items-center gap-4 sm:gap-6">
            <MiniCardStats title="Total Days" idP="totalDays" />
          </div>
        </div>
      </div>

      <div class="divider my-2 sm:my-4"></div>

      <!-- Top 100 Listened Artists -->
      <TopArtistItem />

      <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-6 sm:mb-8 text-primary bg-clip-text">
        Top 100 Listened Artists
      </h1>

      <div id="topArtistsContainer" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>

      <!-- Top 100 Listened Songs -->
    </div>
    <div class="text-center text-sm text-base-content/70">
      <p>Note: All processing is done locally in your browser. Your data is not uploaded or stored anywhere.</p>
    </div>
  </section>

  <script>
    import type { SpotifyExtendedStreamingHistory } from "../interfaces/SpotifyExtendedStreamingHistory.ts";
    import type { ResultTopp100Artist } from "../interfaces/ResultTopp100Artist.ts";
    import type { BasicInfo } from "../interfaces/BasicInfo.ts";

    // ------------------- VARIABLES HTML -------------------
    const input = document.getElementById("jsonInput") as HTMLInputElement;
    const divDataNoLoaded = document.getElementById("divDataNoLoaded") as HTMLDivElement;
    const divDataLoaded = document.getElementById("divDataLoaded") as HTMLDivElement;
    const loadingOverlay = document.getElementById("loadingOverlay") as HTMLDivElement;
    const totalSongsPlayed = document.getElementById("totalSongsPlayed") as HTMLParagraphElement;
    const diferentSongs = document.getElementById("diferentSongs") as HTMLParagraphElement;
    const totalMinutes = document.getElementById("totalMinutes") as HTMLParagraphElement;
    const diferentArtists = document.getElementById("diferentArtists") as HTMLParagraphElement;
    const totalHours = document.getElementById("totalHours") as HTMLParagraphElement;
    const diferentAlbums = document.getElementById("diferentAlbums") as HTMLParagraphElement;
    const totalDays = document.getElementById("totalDays") as HTMLParagraphElement;

    const template = document.getElementById("topArtistTemplate") as HTMLTemplateElement;
    const clone = template.content.cloneNode(true) as DocumentFragment;

    // --------------------------------------------------------------

    // ------------------- VARIABLES LOCALSTORAGE -------------------
    const cachedTop100 = localStorage.getItem("top100ArtistsCache");
    const cachedBasicInfo = localStorage.getItem("basicInfoCache");
    // --------------------------------------------------------------

    // ------------------- VARIABLES GLOBALES -------------------
    let allData: SpotifyExtendedStreamingHistory[] = [];
    const userLocale = navigator.language || "en-US";
    // --------------------------------------------------------------

    if (cachedBasicInfo && cachedTop100) {
      console.log("Using cached data on load.");
      const basicInfo: BasicInfo = JSON.parse(cachedBasicInfo);
      renderBasicInfo(basicInfo);

      const top100Artists: ResultTopp100Artist[] = JSON.parse(cachedTop100);
      renderTopArtists(top100Artists);

      if (divDataNoLoaded) divDataNoLoaded.className = "hidden";
      if (divDataLoaded) divDataLoaded.className = "";
    }

    input?.addEventListener("change", async () => {
      const files = input.files;
      if (files === null) return;
      if (!files.length) return;

      await inputFileChange(files);
      processData(allData);
    });

    async function inputFileChange(files: FileList) {
      allData = [];

      for (const file of files) {
        const text = await file.text();

        try {
          const json = JSON.parse(text);
          allData.push(...json);
        } catch (e) {
          console.error("Error reading " + file.name);
        }
      }
    }

    function filtredOnlySongs(data: SpotifyExtendedStreamingHistory[]) {
      return data.filter((record: SpotifyExtendedStreamingHistory) => record.master_metadata_album_artist_name);
    }

    function processBasicInfo(songsData: SpotifyExtendedStreamingHistory[]) {
      let TotalSongsPlayed: number = 0;
      let TotalMinutes: number = 0;
      let TotalHours: number = 0;
      let TotalDays: number = 0;
      let DifferentSongs: number = 0;
      let DifferentArtists: number = 0;
      let DifferentAlbums: number = 0;

      TotalSongsPlayed = songsData.length;

      // Different Songs
      const uniqueSongs = new Set(
        songsData.map(
          (song: SpotifyExtendedStreamingHistory) =>
            song.master_metadata_track_name + " - " + song.master_metadata_album_artist_name
        )
      ).size;

      DifferentSongs = uniqueSongs;

      // Total Minutes
      const totalMinutesPlayed = Math.floor(
        songsData.reduce((acc: number, song: SpotifyExtendedStreamingHistory) => acc + song.ms_played, 0) / 60000
      );

      TotalMinutes = totalMinutesPlayed;

      // Different Artists
      const uniqueArtists = new Set(
        songsData.map((song: SpotifyExtendedStreamingHistory) => song.master_metadata_album_artist_name)
      ).size;

      DifferentArtists = uniqueArtists;

      // Total Hours
      const totalHoursPlayed = Math.floor(totalMinutesPlayed / 60);

      TotalHours = totalHoursPlayed;

      // Different Albums
      const uniqueAlbums = new Set(
        songsData.map(
          (song: SpotifyExtendedStreamingHistory) =>
            song.master_metadata_album_album_name + " - " + song.master_metadata_album_artist_name
        )
      ).size;

      DifferentAlbums = uniqueAlbums;

      // Total Days
      TotalDays = Math.floor(totalHoursPlayed / 24);

      let basicInfo: BasicInfo = {
        TotalSongsPlayed: TotalSongsPlayed,
        DifferentSongs: DifferentSongs,
        TotalMinutes: TotalMinutes,
        DifferentArtists: DifferentArtists,
        TotalHours: TotalHours,
        DifferentAlbums: DifferentAlbums,
        TotalDays: TotalDays,
      };

      localStorage.setItem("basicInfoCache", JSON.stringify(basicInfo));
      return basicInfo;
    }

    async function processData(data: SpotifyExtendedStreamingHistory[]) {
      if (loadingOverlay) loadingOverlay.classList.remove("hidden");
      const songsData: SpotifyExtendedStreamingHistory[] = filtredOnlySongs(data);

      const top100Artists: ResultTopp100Artist[] = await getTop100Artists(songsData);
      renderTopArtists(top100Artists);

      const basicInfo = processBasicInfo(songsData);
      renderBasicInfo(basicInfo);

      if (divDataNoLoaded) divDataNoLoaded.className = "hidden";
      if (divDataLoaded) divDataLoaded.className = "";
      if (loadingOverlay) loadingOverlay.classList.add("hidden");
    }

    function renderBasicInfo(basicInfo: BasicInfo) {
      if (totalSongsPlayed)
        totalSongsPlayed.textContent = `${basicInfo.TotalSongsPlayed.toLocaleString(userLocale)} plays`;
      if (diferentSongs)
        diferentSongs.textContent = `${basicInfo.DifferentSongs.toLocaleString(userLocale)} different songs`;
      if (totalMinutes) totalMinutes.textContent = `${basicInfo.TotalMinutes.toLocaleString(userLocale)} minutes`;
      if (diferentArtists)
        diferentArtists.textContent = `${basicInfo.DifferentArtists.toLocaleString(userLocale)} different artists`;
      if (totalHours) totalHours.textContent = `${basicInfo.TotalHours.toLocaleString(userLocale)} hours`;
      if (diferentAlbums)
        diferentAlbums.textContent = `${basicInfo.DifferentAlbums.toLocaleString(userLocale)} different albums`;
      if (totalDays) totalDays.textContent = `${basicInfo.TotalDays.toLocaleString(userLocale)} days`;
    }

    function renderTopArtists(top100: any[]) {
      const container = document.getElementById("topArtistsContainer");

      if (!container || !template) return;

      container.innerHTML = "";

      top100.forEach((item, index) => {
        const clone = template.content.cloneNode(true) as DocumentFragment;
        const nameEl = clone.querySelector(".artist-name") as HTMLElement;
        const minutesEl = clone.querySelector(".artist-minutes") as HTMLElement;
        const playsEl = clone.querySelector(".artist-plays") as HTMLElement;
        const imgEl = clone.querySelector(".artist-image") as HTMLImageElement;

        nameEl.textContent = `#${index + 1} ${item.artist}`;
        minutesEl.textContent = `${item.minutes.toLocaleString("es-ES")} minutos escuchados`;
        playsEl.textContent = `${item.plays.toLocaleString("es-ES")} reproducciones`;

        imgEl.src = item.artistImage;
        imgEl.alt = `Foto de ${item.artist}`;

        container.appendChild(clone);
      });
    }

    async function getTop100Artists(data: SpotifyExtendedStreamingHistory[]) {
      const artistsMap = new Map();

      for (const record of data) {
        const artist = record.master_metadata_album_artist_name;
        const ms = record.ms_played || 0;

        if (!artist) continue; // ignorar registros sin artista

        if (!artistsMap.has(artist)) {
          artistsMap.set(artist, {
            artist,
            totalMs: 0,
            plays: 0,
            idTrack: record.spotify_track_uri,
          });
        }

        const entry = artistsMap.get(artist);
        entry.totalMs += ms;
        entry.plays += 1;
      }

      const result: ResultTopp100Artist[] = [...artistsMap.values()]
        .sort((a, b) => b.totalMs - a.totalMs)
        .slice(0, 100)
        .map((item) => ({
          artist: item.artist,
          minutes: Math.floor(item.totalMs / 60000),
          plays: item.plays,
          idTrack: item.idTrack,
          artistImage: "",
        }));

      await Promise.all(result);
      await cargarImagenesArtistas(result);

      // Guardar resultado en cach√©
      localStorage.setItem("top100ArtistsCache", JSON.stringify(result));
      console.log("Top 100 artists cached.");
      return result;
    }

    function delay(ms: number) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function cargarImagenesArtistas(result: ResultTopp100Artist[]) {
      for (const item of result) {
        const trackId = item.idTrack?.split(":")[2];
        if (!trackId) {
          item.artistImage = "";
          continue;
        }

        try {
          // --- PETICI√ìN TRACK ---
          const trackRes = await fetch(`/api/spotify/track?id=${trackId}`);
          if (!trackRes.ok) {
            console.warn("Error track:", trackRes.status);
            item.artistImage = "";
            continue;
          }

          const sonData = await trackRes.json();
          const artistaUri = sonData.artists?.[0]?.uri;

          if (!artistaUri) {
            item.artistImage = "";
            continue;
          }

          const artista = artistaUri.replace("spotify:artist:", "");

          // Esperar 500 ms antes de la siguiente petici√≥n
          await delay(100);

          // --- PETICI√ìN ARTISTA ---
          const artistRes = await fetch(`/api/spotify/artist?id=${artista}`);
          if (!artistRes.ok) {
            console.warn("Error artist:", artistRes.status);
            item.artistImage = "";
            continue;
          }

          const artistData = await artistRes.json();
          item.artistImage = artistData.images?.[0]?.url || "";
        } catch (err) {
          console.error("Error cargando artista", item.artist, err);
          item.artistImage = "";
        }
      }

      return result;
    }
  </script>
</MainLayout>

---
import MainLayout from "../layouts/MainLayout.astro";
import MiniCardStats from "../components/MiniCardStats.astro";
import TopArtistItem from "../components/TopArtistItem.astro";
import Loading from "../components/Loading.astro";
---

<MainLayout content={{ title: "History Stats" }}>
  <Loading />
  <section class="p-6 max-w-7xl mx-auto text-white">
    <div id="divDataNoLoaded" class="flex flex-col items-center mt-10">
      <h1 class="text-4xl font-extrabold text-center mb-4 text-white">
        Upload Your Spotify History
      </h1>

      <p class="text-gray-400 text-center max-w-md mb-6">
        Upload your <b>Streaming History JSON</b> files to generate your personalized
        listening stats.
      </p>

      <div
        class="bg-[#0f172a] p-8 rounded-2xl shadow-xl border border-gray-700 max-w-md w-full flex flex-col items-center gap-5"
      >
        <!-- Icono moderno -->
        <div
          class="bg-[#1e293b] p-4 rounded-full shadow-md border border-gray-600"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="w-10 h-10 text-green-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1M16 12l-4 4m0 0l-4-4m4 4V4"
            ></path>
          </svg>
        </div>

        <p class="text-gray-300 text-center">
          Drag and drop your <b>.json</b> files or choose them manually.
        </p>

        <!-- Bot√≥n -->
        <label
          for="jsonInput"
          class="cursor-pointer px-6 py-3 bg-green-600 hover:bg-green-700 transition-colors text-white font-medium rounded-lg shadow-md w-fit"
        >
          üìÅ Select JSON Files
        </label>

        <!-- Input oculto -->
        <input
          type="file"
          id="jsonInput"
          class="hidden"
          accept="application/json"
          multiple
        />
      </div>
    </div>

    <div id="divDataLoaded" class="hidden">
      <div class="grid grid-cols-2 gap-4 sm:gap-6">
        <MiniCardStats title="Total Songs Played" idP="totalSongsPlayed" />
        <MiniCardStats title="Different Songs" idP="diferentSongs" />
        <MiniCardStats title="Total Minutes" idP="totalMinutes" />
        <MiniCardStats title="Different Artists" idP="diferentArtists" />
        <MiniCardStats title="Total Hours" idP="totalHours" />
        <MiniCardStats title="Different Albums" idP="diferentAlbums" />
        <div class="col-span-2 grid place-items-center gap-4 sm:gap-6">
          <MiniCardStats title="Total Days" idP="totalDays" />
        </div>
      </div>

      <div class="divider my-2 sm:my-4"></div>

      <!-- Top 100 Listened Artists -->
      <TopArtistItem />
      <div
        id="topArtistsContainer"
        class="grid grid-cols-1 sm:grid-cols-4 gap-4"
      >
        <h1
          class="text-2xl sm:text-3xl font-bold mb-2 sm:mb-4 col-span-4 text-center"
        >
          Top 100 Listened Artists
        </h1>
      </div>

      <!-- Top 100 Listened Songs -->
    </div>
    <div class="text-center text-sm text-base-content/70">
      <p>
        Note: All processing is done locally in your browser. Your data is not
        uploaded or stored anywhere.
      </p>
    </div>
  </section>

  <script>
    import { array } from "astro:schema";
    import { getSong, getArtist } from "../lib/spotify";
    import { getAccesTokenCookie } from "../lib/utils";

    let allData = [];

    const input:any = document.getElementById("jsonInput") ;
    const divDataNoLoaded = document.getElementById("divDataNoLoaded");

    input?.addEventListener("change", async () => {
      const files = input.files;
      if (!files.length) return;

      allData = [];

      for (const file of files) {
        const text = await file.text();

        try {
          const json = JSON.parse(text);
          allData.push(...json);
        } catch (e) {
          console.error("Error reading " + file.name);
        }
      }

      processData(allData);
    });

    function filtredOnlySongs(data: any) {
      return data.filter(
        (record: any) => record.master_metadata_album_artist_name
      );
    }

    function processBasicInfo(songsData: any) {
      const totalSongsPlayed = document.getElementById("totalSongsPlayed");
      const diferentSongs = document.getElementById("diferentSongs");
      const totalMinutes = document.getElementById("totalMinutes");
      const diferentArtists = document.getElementById("diferentArtists");
      const totalHours = document.getElementById("totalHours");
      const diferentAlbums = document.getElementById("diferentAlbums");
      const totalDays = document.getElementById("totalDays");

      // Total Songs Played
      if (totalSongsPlayed)
        totalSongsPlayed.textContent = `${songsData.length.toLocaleString("en-US")} plays`;

      // Different Songs
      const uniqueSongs = new Set(
        songsData.map(
          (song: any) =>
            song.master_metadata_track_name +
            " - " +
            song.master_metadata_album_artist_name
        )
      ).size;
      if (diferentSongs) {
        diferentSongs.textContent = `${uniqueSongs.toLocaleString("en-US")} different songs`;
      }

      // Total Minutes
      const totalMinutesPlayed = Math.floor(
        songsData.reduce((acc: any, song: any) => acc + song.ms_played, 0) /
          60000
      );
      if (totalMinutes) {
        totalMinutes.textContent = `${totalMinutesPlayed.toLocaleString("en-US")} minutes`;
      }

      // Different Artists
      const uniqueArtists = new Set(
        songsData.map((song: any) => song.master_metadata_album_artist_name)
      ).size;

      if (diferentArtists)
        diferentArtists.textContent = `${uniqueArtists.toLocaleString("en-US")} different artists`;

      // Total Hours
      const totalHoursPlayed = Math.floor(totalMinutesPlayed / 60);

      if (totalHours)
        totalHours.textContent = `${totalHoursPlayed.toLocaleString("en-US")} hours`;

      // Different Albums
      const uniqueAlbums = new Set(
        songsData.map(
          (song: any) =>
            song.master_metadata_album_name +
            " - " +
            song.master_metadata_album_artist_name
        )
      ).size;

      if (diferentAlbums)
        diferentAlbums.textContent = `${uniqueAlbums.toLocaleString("en-US")} different albums`;

      // Total Days
      if (totalDays)
        totalDays.textContent = `${Math.floor(totalHoursPlayed / 24).toLocaleString("en-US")} days`;
    }

    async function processData(data: any) {
      const loadingOverlay = document.getElementById("loadingOverlay");
      if (loadingOverlay) loadingOverlay.classList.remove("hidden");
      const songsData = filtredOnlySongs(data);
      const divDataLoaded = document.getElementById("divDataLoaded");
      // Top 100 Artists
      const token = await getAccesTokenCookie();
      const top100Artists = getTop100Artists(songsData);

      processBasicInfo(songsData);
      await renderTopArtists(top100Artists);

      if (divDataNoLoaded) divDataNoLoaded.className = "hidden";
      if (divDataLoaded) divDataLoaded.className = "";
      if (loadingOverlay) loadingOverlay.classList.add("hidden");
    }

    async function renderTopArtists(top100: any) {
      var total = top100.length;
      var count = 0;
      for (const item of top100) {
        count++;
        var trackId = item.idTrack?.split(":")[2];

        var token = await getAccesTokenCookie();

        var sonData = await getSong(token, trackId);
        var artista = sonData.artists[0].uri.replace("spotify:artist:", "");

        // Pausa REAL y en SERIE
        await new Promise((resolve) => setTimeout(resolve, 100));

        var artistData = await getArtist(token, artista);
        var image = artistData.images[0]?.url || "";

        // Aqu√≠ el fix üëá
        item.artistImage = image;
        console.log(`Processed ${count} of ${total} artists`);
      }
      console.log("Top 100 with images:", top100);

      const container = document.getElementById("topArtistsContainer");
      const template = document.getElementById("topArtistTemplate");

      if (container == null || template == null) return;
      container.innerHTML = ""; // limpiar antes

      var i = 0;
      top100.forEach((item: any) => {
        i++;
        const clone: any = template.cloneNode(true);
        clone.id = ""; // eliminar ID duplicado
        clone.classList.remove("hidden");

        clone.querySelector(".artist-name").textContent =
          "#" + i + " " + item.artist;
        clone.querySelector(".artist-minutes").textContent =
          `${item.minutes} minutos escuchados`;
        clone.querySelector(".artist-plays").textContent =
          `${item.plays} reproducciones`;

        clone.querySelector(".artist-image").src = item.artistImage;

        container.appendChild(clone);
      });
    }

    function getTop100Artists(data: any) {
      const artistsMap = new Map();

      for (const record of data) {
        const artist = record.master_metadata_album_artist_name;
        const ms = record.ms_played || 0;

        if (!artist) continue; // ignorar registros sin artista

        if (!artistsMap.has(artist)) {
          artistsMap.set(artist, {
            artist,
            totalMs: 0,
            plays: 0,
            idTrack: record.spotify_track_uri,
          });
        }

        const entry = artistsMap.get(artist);
        entry.totalMs += ms;
        entry.plays += 1;
      }

      const result = [...artistsMap.values()]
        .sort((a, b) => b.totalMs - a.totalMs)
        .slice(0, 100)
        .map((item) => ({
          artist: item.artist,
          minutes: Math.floor(item.totalMs / 60000),
          plays: item.plays,
          idTrack: item.idTrack,
        }));

      return result;
    }
  </script>
</MainLayout>
